import pytest

import numpy as np
import sympy as sp
from devitoboundary import StencilGen
from devitoboundary.symbolics.symbols import x_b, a, x_c, x_a, u_x_a
from devitoboundary.stencils.stencil_utils import generic_function
from devito import Eq

s_o = 4  # Order of the discretization


class TestStencils:
    """
    A class for testing the stencils generated by StencilGen
    """

    @pytest.mark.parametrize('offset', [-0.5, 0, 0.5])
    def test_convergence(self, offset):
        """
        Convergence test to check that calculated derivatives trend towards
        the actual with decreasing grid increment.
        """
        bc_0 = Eq(generic_function(x_b), 0)
        bc_2 = Eq(generic_function(x_b, 2), 0)
        bcs = [bc_0, bc_2]

        ext = StencilGen(s_o, bcs)

        ext.all_variants(2, offset)

        for i in range(1, len(ext.stencils)):
            prev = None
            print("\n Variant", i)
            test_eta_r = 0.5*s_o - 0.5*i + 0.25
            test_stencil = ext.stencils_lambda[0, i]
            for j in range(1, 11):
                dx = 1/j
                # evaluated = test_stencil
                evaluated = 0
                for k in range(len(ext.stencils)):
                    func = test_stencil[k]
                    multiplier = np.sin(np.pi-test_eta_r*dx+(k-int(s_o/2))*dx)
                    evaluated += multiplier*func(0, test_eta_r)
                evaluated /= dx**2
                diff = evaluated + np.sin(np.pi-test_eta_r*dx+offset*dx)
                print(diff)
                if prev is not None:
                    if abs(diff) > abs(prev) and not np.isclose(np.finfo(np.float32).eps, float(diff), rtol=10):
                        raise RuntimeError("Convergence failed. Diff: %f Prev: %f" % (abs(diff), abs(prev)))
                prev = diff

    @pytest.mark.parametrize('order', [2, 4, 6])
    def test_extrapolations(self, order):
        """
        Test to check that extrapolations recover polynomials of equivalent order.
        """
        def poly_gen(val, poly_order):
            poly = 0
            for i in range(1, poly_order+1):
                if i % 2 == 0:
                    poly += val**(i-1)
            return poly

        zero_bcs = [Eq(generic_function(x_b, 2*i), 0)
                    for i in range(1+order//2)]

        ext = StencilGen(order, zero_bcs)
        e_poly_coeffs = ext._coeff_gen(order)

        e_poly = sum([e_poly_coeffs[a[i]]*x_c**i
                      for i in range(len(e_poly_coeffs))])

        t_poly = poly_gen((x_c-x_b), order)

        for i in range(1+order//2):
            e_poly = e_poly.subs([(x_a[i], x_b - (1+i)),
                                  (u_x_a[i], t_poly.subs(x_c, x_b - (1+i)))])

        assert sp.simplify(e_poly-t_poly) == 0, "Polynomial was not recovered"

    @pytest.mark.parametrize('order', [4])
    @pytest.mark.parametrize('derivative', [1, 2])
    def test_single_sided(self, order, derivative):
        """
        Test to check that single-sided stencils adequately approximate the
        original derivative.
        """
        # Accuracy
        thres = 0.09
        # Note: dx = 1 for simplicity

        def quad(x, eta, deriv=0):
            # FIXME: Needs to be wayyy higher order
            if deriv == 0:
                return (x - eta)*(x + order)
            elif deriv == 1:
                return 2*x - eta + order
            elif deriv == 2:
                return 2

        bcs = [Eq(generic_function(x_b, 2*i), 0)
               for i in range(1+order//2)]

        ext = StencilGen(order, bcs)

        ext.all_variants(derivative, 0)

        errors = []

        # As left and right single sided are mirrored, fix left variant at 0
        # Skip last variant, as it is usually not too accurate
        for var in range(1, order):
            # Set max and min etas for the variant
            # Will have 9 (10+1-2) etas per variant
            min_eta = order//2 - 0.5*var + 0.05
            max_eta = order//2 - 0.5*(var-1) - 0.05
            eta = np.linspace(min_eta, max_eta, 9)[::-1]

            stencil = ext.stencils_lambda[0, var]

            for eta_val in eta:
                evaluated = 0
                for coeff in range(order+1):
                    func = stencil[coeff]
                    multiplier = quad(coeff-order//2, eta_val)
                    evaluated += multiplier*func(0, eta_val)
                err = abs(evaluated-quad(0, eta_val, deriv=derivative))
                errors.append(err)

        assert np.median(errors) < thres

    @pytest.mark.parametrize('order', [4])
    @pytest.mark.parametrize('derivative', [1, 2])
    def test_double_sided(self, order, derivative):
        """
        Test to check that double-sided stencils adequately approximate the
        original derivative.
        """
        # Accuracy
        thres = 0.13
        # Note: dx = 1 for simplicity

        def quad(x, eta_left, eta_right, deriv=0):
            # FIXME: Needs to be wayyyy higher order
            if deriv == 0:
                return (x - eta_left)*(x - eta_right)
            elif deriv == 1:
                return 2*x - eta_left - eta_right
            elif deriv == 2:
                return 2

        bcs = [Eq(generic_function(x_b, 2*i), 0)
               for i in range(1+order//2)]

        ext = StencilGen(order, bcs)

        ext.all_variants(derivative, 0)

        errors = []

        # Loop over left and right variants starting at zero
        # Skip last variant, as it is usually not too accurate
        for var_l in range(1, order):
            # Set max and min etas for the left variant
            # Will have 9 (10+1-2) etas per variant
            min_eta_l = order//2 - 0.5*var_l + 0.05
            max_eta_l = order//2 - 0.5*(var_l-1) - 0.05
            eta_left = -np.linspace(min_eta_l, max_eta_l, 9)[::-1]
            for var_r in range(1, order):
                min_eta_r = order//2 - 0.5*var_r + 0.05
                max_eta_r = order//2 - 0.5*(var_r-1) - 0.05
                eta_right = np.linspace(min_eta_r, max_eta_r, 9)[::-1]

                stencil = ext.stencils_lambda[var_l, var_r]

                for eta_val_l in eta_left:
                    for eta_val_r in eta_right:
                        evaluated = 0
                        for coeff in range(order+1):
                            func = stencil[coeff]
                            multiplier = quad(coeff-order//2,
                                              eta_val_l, eta_val_r)
                            evaluated += multiplier*func(eta_val_l, eta_val_r)
                        err = abs(evaluated-quad(0, eta_val_l, eta_val_r,
                                                 deriv=derivative))
                        errors.append(err)
        assert np.median(errors) < thres
