import pytest

import numpy as np
import sympy as sp
from devitoboundary import StencilGen
from devitoboundary.symbolics.symbols import (x_b, f, eta_r, eta_l, a, x_c, x_a,
                                              u_x_a)
from devitoboundary.stencils.stencil_utils import generic_function
from devito import Eq

s_o = 4  # Order of the discretization


class TestStencils:
    """
    A class for testing the stencils generated by StencilGen
    """

    @pytest.mark.parametrize('offset', [-0.5, 0, 0.5])
    def test_convergence(self, offset):
        """
        Convergence test to check that calculated derivatives trend towards
        the actual with decreasing grid increment.
        """
        bc_0 = Eq(generic_function(x_b), 0)
        bc_2 = Eq(generic_function(x_b, 2), 0)
        bcs = [bc_0, bc_2]

        ext = StencilGen(s_o, bcs)

        ext.all_variants(2, offset)

        for i in range(1, len(ext.stencils)):
            prev = None
            print("\n Variant", i)
            test_eta_r = 0.5*s_o - 0.5*i + 0.25
            test_stencil = ext.stencils_lambda[0, i]
            for j in range(1, 11):
                dx = 1/j
                # evaluated = test_stencil
                evaluated = 0
                for k in range(len(ext.stencils)):
                    func = test_stencil[k]
                    multiplier = np.sin(np.pi-test_eta_r*dx+(k-int(s_o/2))*dx)
                    evaluated += multiplier*func(0, test_eta_r)
                evaluated /= dx**2
                diff = evaluated + np.sin(np.pi-test_eta_r*dx+offset*dx)
                print(diff)
                if prev is not None:
                    if abs(diff) > abs(prev) and not np.isclose(np.finfo(np.float32).eps, float(diff), rtol=10):
                        raise RuntimeError("Convergence failed. Diff: %f Prev: %f" % (abs(diff), abs(prev)))
                prev = diff

    @pytest.mark.parametrize('order', [2, 4, 6])
    def test_extrapolations(self, order):
        """
        Test to check that extrapolations recover polynomials of equivalent order.
        """
        def poly_gen(val, poly_order):
            poly = 0
            for i in range(1, poly_order+1):
                if i % 2 == 0:
                    poly += val**(i-1)
            return poly

        zero_bcs = [Eq(generic_function(x_b, 2*i), 0)
                    for i in range(1+order//2)]

        ext = StencilGen(order, zero_bcs)
        e_poly_coeffs = ext._coeff_gen(order)

        e_poly = sum([e_poly_coeffs[a[i]]*x_c**i
                      for i in range(len(e_poly_coeffs))])

        t_poly = poly_gen((x_c-x_b), order)

        for i in range(1+order//2):
            e_poly = e_poly.subs([(x_a[i], x_b - (1+i)),
                                  (u_x_a[i], t_poly.subs(x_c, x_b - (1+i)))])

        assert sp.simplify(e_poly-t_poly) == 0, "Polynomial was not recovered"

    def test_double_sided(self):
        """
        Test to check that double sided stencils adequately approximate the original
        derivative.
        """
        bc_0 = Eq(generic_function(x_b), 0)
        bc_2 = Eq(generic_function(x_b, 2), 0)
        bcs = [bc_0, bc_2]

        ext = StencilGen(s_o, bcs)

        ext.all_variants(2)

        dx = 1

        def quadratic(x, eta_l, eta_r):
            return (x - eta_r*dx)*(x - eta_l*dx)

        # l_vals = np.linspace(-0.75, -1.75, 10)
        # r_vals = np.linspace(0.75, 1.75, 10)
        l_vals = np.linspace(-1.05, -1.95, 19)
        r_vals = np.linspace(1.05, 1.95, 19)
        avg_tol = 0

        for i in range(l_vals.shape[0]):
            for j in range(r_vals.shape[0]):
                # stencil = ext.subs(eta_l=l_vals[i], eta_r=r_vals[j])
                dist_l = s_o - np.ceil(abs(l_vals[i])*2).astype(np.int) + 1
                sub_l = l_vals[i]
                dist_r = s_o - np.ceil(r_vals[j]*2).astype(np.int) + 1
                sub_r = r_vals[j]
                stencil_expr = ext._stencil_list[dist_l][dist_r].subs([(eta_l, sub_l),
                                                                       (eta_r, sub_r)])

                stencil = np.empty(s_o+1)
                for i in range(s_o+1):
                    stencil[i] = float(stencil_expr.coeff(f[i-int(s_o/2)], 1))

                stencil /= dx**2
                derivative = 0
                for k in range(stencil.shape[0]):
                    derivative += stencil[k]*quadratic(k*dx - dx*s_o/2, l_vals[i], r_vals[j])
                assert 100*abs(derivative-2)/2 < 20, "Accuracy of calculated derivative insufficient"
                avg_tol += abs(derivative-2)

        assert 100*(avg_tol/(19**2))/2 < 9, "Average accuracy of calculated derivatives insufficient"
